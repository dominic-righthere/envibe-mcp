import {
  AccessLevel,
  type AIEnvVariable,
  type EnvVariable,
  type Manifest,
  type VariableConfig,
} from "./types";
import { getVariableConfig } from "./manifest";

/**
 * Transform a variable's value based on its access level
 * Returns the display value that AI should see
 */
export function getDisplayValue(
  key: string,
  value: string | undefined,
  config: VariableConfig
): string {
  switch (config.access) {
    case AccessLevel.FULL:
    case AccessLevel.READ_ONLY:
      // AI sees the actual value (or pattern if specified for read-only)
      if (config.access === AccessLevel.READ_ONLY && config.pattern) {
        return config.pattern;
      }
      return value ?? config.default ?? "";

    case AccessLevel.PLACEHOLDER:
      // AI sees a placeholder indicating the variable exists
      return `<${key}>`;

    case AccessLevel.SCHEMA_ONLY:
      // AI sees the schema structure
      if (config.schema) {
        const schemaStr = Object.entries(config.schema)
          .map(([k, v]) => `${k}: "${v}"`)
          .join(", ");
        return `{ ${schemaStr} }`;
      }
      return "<schema>";

    case AccessLevel.HIDDEN:
      // AI doesn't see this at all - shouldn't reach here
      return "";

    default:
      return `<${key}>`;
  }
}

/**
 * Check if AI can modify a variable based on its access level
 */
export function canModify(access: AccessLevel): boolean {
  return access === AccessLevel.FULL;
}

/**
 * Check if AI can see a variable based on its access level
 */
export function canSee(access: AccessLevel): boolean {
  return access !== AccessLevel.HIDDEN;
}

/**
 * Filter environment variables for AI consumption
 * Returns only variables that AI is allowed to see
 */
export function filterForAI(
  env: Record<string, string>,
  manifest: Manifest
): AIEnvVariable[] {
  const result: AIEnvVariable[] = [];

  // First, add all variables that are in the manifest
  for (const [key, config] of Object.entries(manifest.variables)) {
    if (!canSee(config.access)) {
      continue;
    }

    const value = env[key];
    result.push({
      key,
      displayValue: getDisplayValue(key, value, config),
      access: config.access,
      description: config.description,
      canModify: canModify(config.access),
    });
  }

  // Then, add any env variables not in manifest (with default placeholder access)
  for (const key of Object.keys(env)) {
    if (manifest.variables[key]) {
      continue; // Already processed
    }

    // Unclassified variables default to placeholder for safety
    const defaultConfig: VariableConfig = {
      access: AccessLevel.PLACEHOLDER,
      description: "Unclassified variable",
    };

    result.push({
      key,
      displayValue: getDisplayValue(key, env[key], defaultConfig),
      access: defaultConfig.access,
      description: defaultConfig.description,
      canModify: canModify(defaultConfig.access),
    });
  }

  // Sort alphabetically for consistent output
  result.sort((a, b) => a.key.localeCompare(b.key));

  return result;
}

/**
 * Generate .env.ai file content from filtered variables
 */
export function generateAIEnvContent(variables: AIEnvVariable[]): string {
  const lines: string[] = [
    "# Generated by envibe - AI-safe view of environment variables",
    "# See .env.manifest.yaml for access rules",
    "# DO NOT EDIT - regenerate with: envibe generate",
    "",
  ];

  for (const variable of variables) {
    const accessTag = `[${variable.access}]`;
    const description = variable.description ? ` ${variable.description}` : "";

    if (variable.access === AccessLevel.SCHEMA_ONLY) {
      // Schema-only variables are shown as comments
      lines.push(`# ${variable.key}: schema ${variable.displayValue}`);
    } else {
      lines.push(
        `${variable.key}=${variable.displayValue}  # ${accessTag}${description}`
      );
    }
  }

  return lines.join("\n") + "\n";
}

/**
 * Parse a modification request from AI
 * Validates that the variable can be modified
 */
export function validateModification(
  key: string,
  manifest: Manifest
): { allowed: boolean; reason?: string } {
  const config = getVariableConfig(manifest, key);

  if (config.access === AccessLevel.HIDDEN) {
    return {
      allowed: false,
      reason: `Variable "${key}" is hidden and cannot be accessed`,
    };
  }

  if (!canModify(config.access)) {
    return {
      allowed: false,
      reason: `Variable "${key}" has access level "${config.access}" and cannot be modified. Only "full" access variables can be modified.`,
    };
  }

  return { allowed: true };
}

/**
 * Get a single variable for AI consumption
 */
export function getVariableForAI(
  key: string,
  env: Record<string, string>,
  manifest: Manifest
): AIEnvVariable | null {
  const config = getVariableConfig(manifest, key);

  if (!canSee(config.access)) {
    return null;
  }

  const value = env[key];
  return {
    key,
    displayValue: getDisplayValue(key, value, config),
    access: config.access,
    description: config.description,
    canModify: canModify(config.access),
  };
}
